"""Blob detection and tracking."""

import numpy as np
import cv2
import cv2.cv as cv
from util import Enum
from base import DependentFrameProcessor
from main import main
from colorfilter import ColorFilterProcessor

class Blob:
  """Represents a colored blob, with associated properties."""
  
  def __init__(self, contour, tag, area=None):
    self.contour = contour
    self.tag = tag
    self.area = area if area is not None else cv2.contourArea(contour)  # area should've been pre-computed
    self.bbox = cv2.boundingRect(contour)
    self.rect = cv2.minAreaRect(contour)
    # TODO define other properties
  
  def draw(self, imageOut):
    cv2.drawContours(imageOut, [self.contour], 0, (0, 255, 0), 2)
    cv2.rectangle(imageOut, (self.bbox[0], self.bbox[1]), (self.bbox[0] + self.bbox[2], self.bbox[1] + self.bbox[3]), (255, 0, 0), 2)
    
    # TODO Draw rotated rect
    #rectCenter = self.rect[0]
    #rectSize = self.rect[1]
    #rectAngle = self.rect[2]
    #rectBox = np.int0(cv.BoxPoints(self.rect))
    #print rectBox
    #cv2.polylines(imageOut, rectBox, True, (0, 0, 255), 2)  # NOTE doesn't work
    #cv2.drawContours(imageOut, [rectBox], 0, (0, 0, 255), 2)


class BlobTracker(DependentFrameProcessor):
  """Detects and tracks colored blobs using masks generated by a color filter, if available."""
  
  State = Enum(['INIT', 'LIVE'])
  minBlobArea = 500
  
  def __init__(self, options, processorPool):
    DependentFrameProcessor.__init__(self, options, processorPool)
    self.colorFilterProcessor = processorPool.getProcessorByType(ColorFilterProcessor)  # keep a reference to a ColorFilterProcessor, if given
    #self.debug = True  # overriding debug flag
    self.state = self.State.INIT
  
  def initialize(self, imageIn, timeNow):
    self.image = imageIn
    self.imageSize = (self.image.shape[1], self.image.shape[0])  # (width, height)
    self.imageOut = None
    self.morphOpenKernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5))
    self.state = self.State.LIVE
    self.active = True
  
  def process(self, imageIn, timeNow):
    self.image = imageIn
    self.imageOut = self.image.copy()
    
    self.blobs = []  # initialize list of current blobs (NOTE per mask or all in one?)
    
    # * If we have a ColorFilterProcessor and it is live
    if (self.colorFilterProcessor is not None) and (self.colorFilterProcessor.state == ColorFilterProcessor.State.LIVE):
      # ** For each available mask
      for maskName, mask in self.colorFilterProcessor.masks.iteritems():
        # *** Smooth out mask and remove noise
        mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, self.morphOpenKernel, iterations=2)
        if self.gui: cv2.imshow(maskName, mask)
        
        # *** Detect contours in mask
        contours, _ = cv2.findContours(mask, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
        if len(contours) > 0:
          #self.logd("process", "[%.2f] %d %s contour(s)" % (timeNow, len(contours), maskName))
          cv2.drawContours(self.imageOut, contours, -1, (0, 255, 255))  # draw all contours found
          
          # **** Walk through list of contours, filter out small ones
          for contour in contours:
            area = cv2.contourArea(contour)
            if area >= self.minBlobArea:
              # ***** Create blob object and add to current list
              blob = Blob(contour, maskName, area)
              self.blobs.append(blob)
        
        # *** TODO Resolve with current blob objects and update properties, add new blobs
        
        # *** TODO Purge lost blobs
    
    # * Draw current blobs
    if len(self.blobs) > 0:
      self.logd("process", "%d blob(s): %s" % (len(self.blobs), ", ".join([blob.tag for blob in self.blobs])))
      for blob in self.blobs:
        blob.draw(self.imageOut)
    
    return True, self.imageOut

# Run a BlobTracker instance using pycv.main.main()
if __name__ == "__main__":
    main(BlobTracker)
